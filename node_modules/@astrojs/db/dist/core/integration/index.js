import { existsSync } from "fs";
import { dirname } from "path";
import { fileURLToPath } from "url";
import { LibsqlError } from "@libsql/client";
import { mkdir, writeFile } from "fs/promises";
import { blue, yellow } from "kleur/colors";
import {
  createServer,
  loadEnv,
  mergeConfig
} from "vite";
import parseArgs from "yargs-parser";
import { AstroDbError } from "../../runtime/utils.js";
import { CONFIG_FILE_NAMES, DB_PATH } from "../consts.js";
import { EXEC_DEFAULT_EXPORT_ERROR, EXEC_ERROR } from "../errors.js";
import { resolveDbConfig } from "../load-file.js";
import { SEED_DEV_FILE_NAME } from "../queries.js";
import { getManagedAppTokenOrExit } from "../tokens.js";
import { getDbDirectoryUrl } from "../utils.js";
import { fileURLIntegration } from "./file-url.js";
import { typegenInternal } from "./typegen.js";
import {
  resolved,
  vitePluginDb
} from "./vite-plugin-db.js";
import { vitePluginInjectEnvTs } from "./vite-plugin-inject-env-ts.js";
function astroDBIntegration() {
  let connectToStudio = false;
  let configFileDependencies = [];
  let root;
  let appToken;
  let tempViteServer;
  let tables = {
    get() {
      throw new Error("[astro:db] INTERNAL Tables not loaded yet");
    }
  };
  let seedFiles = {
    get() {
      throw new Error("[astro:db] INTERNAL Seed files not loaded yet");
    }
  };
  let seedHandler = {
    execute: () => {
      throw new Error("[astro:db] INTERNAL Seed handler not loaded yet");
    },
    inProgress: false
  };
  let command;
  let output = "server";
  return {
    name: "astro:db",
    hooks: {
      "astro:config:setup": async ({ updateConfig, config, command: _command, logger }) => {
        command = _command;
        root = config.root;
        output = config.output;
        if (command === "preview") return;
        let dbPlugin = void 0;
        const args = parseArgs(process.argv.slice(3));
        connectToStudio = process.env.ASTRO_INTERNAL_TEST_REMOTE || args["remote"];
        if (connectToStudio) {
          appToken = await getManagedAppTokenOrExit();
          dbPlugin = vitePluginDb({
            connectToStudio,
            appToken: appToken.token,
            tables,
            root: config.root,
            srcDir: config.srcDir,
            output: config.output,
            seedHandler
          });
        } else {
          dbPlugin = vitePluginDb({
            connectToStudio: false,
            tables,
            seedFiles,
            root: config.root,
            srcDir: config.srcDir,
            output: config.output,
            logger,
            seedHandler
          });
        }
        updateConfig({
          vite: {
            assetsInclude: [DB_PATH],
            plugins: [dbPlugin, vitePluginInjectEnvTs(config, logger)]
          }
        });
      },
      "astro:config:done": async ({ config }) => {
        if (command === "preview") return;
        const { dbConfig, dependencies, integrationSeedPaths } = await resolveDbConfig(config);
        tables.get = () => dbConfig.tables;
        seedFiles.get = () => integrationSeedPaths;
        configFileDependencies = dependencies;
        const localDbUrl = new URL(DB_PATH, config.root);
        if (!connectToStudio && !existsSync(localDbUrl)) {
          await mkdir(dirname(fileURLToPath(localDbUrl)), { recursive: true });
          await writeFile(localDbUrl, "");
        }
        await typegenInternal({ tables: tables.get() ?? {}, root: config.root });
      },
      "astro:server:setup": async ({ server, logger }) => {
        seedHandler.execute = async (fileUrl) => {
          await executeSeedFile({ fileUrl, viteServer: server });
        };
        const filesToWatch = [
          ...CONFIG_FILE_NAMES.map((c) => new URL(c, getDbDirectoryUrl(root))),
          ...configFileDependencies.map((c) => new URL(c, root))
        ];
        server.watcher.on("all", (event, relativeEntry) => {
          const entry = new URL(relativeEntry, root);
          if (filesToWatch.some((f) => entry.href === f.href)) {
            server.restart();
          }
        });
        setTimeout(() => {
          logger.info(
            connectToStudio ? "Connected to remote database." : "New local database created."
          );
          if (connectToStudio) return;
          const localSeedPaths = SEED_DEV_FILE_NAME.map(
            (name) => new URL(name, getDbDirectoryUrl(root))
          );
          if (seedFiles.get().length || localSeedPaths.find((path) => existsSync(path))) {
            server.ssrLoadModule(resolved.module).catch((e) => {
              logger.error(e instanceof Error ? e.message : String(e));
            });
          }
        }, 100);
      },
      "astro:build:start": async ({ logger }) => {
        if (!connectToStudio && !databaseFileEnvDefined() && (output === "server" || output === "hybrid")) {
          const message = `Attempting to build without the --remote flag or the ASTRO_DATABASE_FILE environment variable defined. You probably want to pass --remote to astro build.`;
          const hint = "Learn more connecting to Studio: https://docs.astro.build/en/guides/astro-db/#connect-to-astro-studio";
          throw new AstroDbError(message, hint);
        }
        logger.info("database: " + (connectToStudio ? yellow("remote") : blue("local database.")));
      },
      "astro:build:setup": async ({ vite }) => {
        tempViteServer = await getTempViteServer({ viteConfig: vite });
        seedHandler.execute = async (fileUrl) => {
          await executeSeedFile({ fileUrl, viteServer: tempViteServer });
        };
      },
      "astro:build:done": async ({}) => {
        await appToken?.destroy();
        await tempViteServer?.close();
      }
    }
  };
}
function databaseFileEnvDefined() {
  const env = loadEnv("", process.cwd());
  return env.ASTRO_DATABASE_FILE != null || process.env.ASTRO_DATABASE_FILE != null;
}
function integration() {
  return [astroDBIntegration(), fileURLIntegration()];
}
async function executeSeedFile({
  fileUrl,
  viteServer
}) {
  const mod = await viteServer.ssrLoadModule(fileUrl.pathname);
  if (typeof mod.default !== "function") {
    throw new AstroDbError(EXEC_DEFAULT_EXPORT_ERROR(fileURLToPath(fileUrl)));
  }
  try {
    await mod.default();
  } catch (e) {
    if (e instanceof LibsqlError) {
      throw new AstroDbError(EXEC_ERROR(e.message));
    }
    throw e;
  }
}
async function getTempViteServer({ viteConfig }) {
  const tempViteServer = await createServer(
    mergeConfig(viteConfig, {
      server: { middlewareMode: true, hmr: false, watch: null },
      optimizeDeps: { noDiscovery: true },
      ssr: { external: [] },
      logLevel: "silent"
    })
  );
  const hotSend = tempViteServer.hot.send;
  tempViteServer.hot.send = (payload) => {
    if (payload.type === "error") {
      throw payload.err;
    }
    return hotSend(payload);
  };
  return tempViteServer;
}
export {
  integration
};
